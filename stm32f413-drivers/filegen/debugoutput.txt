found valid can type cmr_canAMKSetpoints_t starting search

successfully parsed mapper data

cmr_canAMKSetpoints_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canAMKSetpoints_t starting search

successfully parsed mapper data

cmr_canAMKSetpoints_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canAMKSetpoints_t starting search

successfully parsed mapper data

cmr_canAMKSetpoints_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canAMKSetpoints_t starting search

successfully parsed mapper data

cmr_canAMKSetpoints_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCOGVelocity_t starting search

successfully parsed mapper data

cmr_canCOGVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCControlsStatus_t starting search

successfully parsed mapper data

cmr_canCDCControlsStatus_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCKiloCoulombs_t starting search

successfully parsed mapper data

cmr_canCDCKiloCoulombs_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canFrontWheelVelocity_t starting search

successfully parsed mapper data

cmr_canFrontWheelVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCOdometer_t starting search

successfully parsed mapper data

cmr_canCDCOdometer_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCPoseOrientation_t starting search

successfully parsed mapper data

cmr_canCDCPoseOrientation_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCPosePosition_t starting search

successfully parsed mapper data

cmr_canCDCPosePosition_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCPoseVelocity_t starting search

successfully parsed mapper data

cmr_canCDCPoseVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCPowerLimitLog_t starting search

successfully parsed mapper data

cmr_canCDCPowerLimitLog_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canPowerSense_t starting search

successfully parsed mapper data

cmr_canPowerSense_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canRearWheelVelocity_t starting search

successfully parsed mapper data

cmr_canRearWheelVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_rtc_data_t starting search

successfully parsed mapper data

cmr_can_rtc_data_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCWheelVelocity_t starting search

successfully parsed mapper data

cmr_canCDCWheelVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCWheelVelocity_t starting search

successfully parsed mapper data

cmr_canCDCWheelVelocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCWheelTorque_t starting search

successfully parsed mapper data

cmr_canCDCWheelTorque_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCWheelTorque_t starting search

successfully parsed mapper data

cmr_canCDCWheelTorque_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_controls_pid_debug_t starting search

successfully parsed mapper data

cmr_can_controls_pid_debug_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_solver_aux_t starting search

successfully parsed mapper data

cmr_can_solver_aux_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_solver_inputs_t starting search

successfully parsed mapper data

cmr_can_solver_inputs_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCWheelTorque_t starting search

successfully parsed mapper data

cmr_canCDCWheelTorque_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_solver_settings_t starting search

successfully parsed mapper data

cmr_can_solver_settings_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canDIMAck_t starting search

successfully parsed mapper data

cmr_canDIMAck_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canDIMActions_t starting search

successfully parsed mapper data

cmr_canDIMActions_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canDIMPowerDiagnostics_t starting search

successfully parsed mapper data

cmr_canDIMPowerDiagnostics_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canDIMRequest_t starting search

successfully parsed mapper data

cmr_canDIMRequest_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCDRSStates_t starting search

successfully parsed mapper data

cmr_canCDCDRSStates_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_front_slip_ratio_data_t starting search

successfully parsed mapper data

cmr_can_front_slip_ratio_data_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_can_front_slip_ratio_data_t starting search

successfully parsed mapper data

cmr_can_front_slip_ratio_data_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_can_front_whl_velocity_t starting search

successfully parsed mapper data

cmr_can_front_whl_velocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canFSMSensorsADC_t starting search

successfully parsed mapper data

cmr_canFSMSensorsADC_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canFSMSensorsADC_t starting search

successfully parsed mapper data

cmr_canFSMSensorsADC_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canFSMPowerDiagnostics_t starting search

successfully parsed mapper data

cmr_canFSMPowerDiagnostics_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canFSMSensorsADC_t starting search

successfully parsed mapper data

cmr_canFSMSensorsADC_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canFSMSensorsADC_t starting search

successfully parsed mapper data

cmr_canFSMSensorsADC_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHeartbeat_t starting search

successfully parsed mapper data

cmr_canHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHeartbeat_t starting search

successfully parsed mapper data

cmr_canHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHeartbeat_t starting search

successfully parsed mapper data

cmr_canHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVCHeartbeat_t starting search

successfully parsed mapper data

cmr_canHVCHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVIHeartbeat_t starting search

successfully parsed mapper data

cmr_canHVIHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHeartbeat_t starting search

successfully parsed mapper data

cmr_canHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHeartbeat_t starting search

successfully parsed mapper data

cmr_canHeartbeat_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canBMSBMBStatusTemp_t starting search

successfully parsed mapper data

cmr_canBMSBMBStatusTemp_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVCBMB_Temp0_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Temp0_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canHVCBMB_Temp1_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Temp1_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canHVCBMB_Temp2_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Temp2_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canBMSBMBStatusVoltage_t starting search

successfully parsed mapper data

cmr_canBMSBMBStatusVoltage_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVCBMB_Voltage0_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Voltage0_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canHVCBMB_Voltage1_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Voltage1_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canHVCBMB_Voltage2_t starting search

successfully parsed mapper data

cmr_canHVCBMB_Voltage2_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canHVCBMBErrors_t starting search

successfully parsed mapper data

cmr_canHVCBMBErrors_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVCCommand_t starting search

successfully parsed mapper data

cmr_canHVCCommand_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canBMSLowVoltage_t starting search

successfully parsed mapper data

cmr_canBMSLowVoltage_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canBMSMinMaxCellTemperature_t starting search

successfully parsed mapper data

cmr_canBMSMinMaxCellTemperature_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canBMSMinMaxCellVoltage_t starting search

successfully parsed mapper data

cmr_canBMSMinMaxCellVoltage_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canBMSPackCurrent_t starting search

successfully parsed mapper data

cmr_canBMSPackCurrent_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canHVCPackVoltage_t starting search

successfully parsed mapper data

cmr_canHVCPackVoltage_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canCDCMotorPower_t starting search

successfully parsed mapper data

cmr_canCDCMotorPower_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_can_rear_slip_ratio_data_t starting search

successfully parsed mapper data

cmr_can_rear_slip_ratio_data_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_can_rear_whl_speed_setpoint_t starting search

successfully parsed mapper data

cmr_can_rear_whl_speed_setpoint_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_can_rear_whl_velocity_t starting search

successfully parsed mapper data

cmr_can_rear_whl_velocity_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

found valid can type cmr_canCDCSafetyFilterStates_t starting search

successfully parsed mapper data

cmr_canCDCSafetyFilterStates_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canTestID_t starting search

successfully parsed mapper data

cmr_canTestID_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canVSMLatchedStatus_t starting search

successfully parsed mapper data

cmr_canVSMLatchedStatus_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canVSMPowerDiagnostics_t starting search

successfully parsed mapper data

cmr_canVSMPowerDiagnostics_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canVSMPowerDiagnostics_t starting search

successfully parsed mapper data

cmr_canVSMPowerDiagnostics_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

found valid can type cmr_canVSMStatus_t starting search

successfully parsed mapper data

cmr_canVSMStatus_t
[('\n    uint8_t state;          /**< @brief Board state. */\n    uint8_t error[2];       /**< @brief Error matrix. */\n    uint8_t warning[2];     /**< @brief Warning matrix. */\n', 'cmr_canHeartbeat_t'), ('\n    uint8_t internalState;  /**< @brief VSM internal state. See cmr_canVSMState_t. */\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMStatus_t'), ('\n    uint16_t brakePressureRear_PSI;     /**< @brief Rear brake pressure (pounds-per-square-inch). */\n    int16_t hallEffect_cA;     /**< @brief Hall effect current (centi-Amps). */\n    uint8_t safetyIn_dV;        /**< @brief Safety circuit input voltage (deci-Volts). */\n    uint8_t safetyOut_dV;       /**< @brief Safety circuit output voltage (deci-Volts). */\n', 'cmr_canVSMSensors_t'), ('\n    /**\n     * @brief Matrix of modules for which at least one message exceeded its error timeout.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t moduleTimeoutMatrix;\n    /**\n     * @brief Matrix of modules that are in the wrong state.\n     * Bits defined by cmr_canVSMErrorSource_t.\n     */\n    uint8_t badStateMatrix;\n    /** @brief Matrix of active error latches. Bits defined by cmr_canVSMLatch_t. */\n    uint8_t latchMatrix;\n', 'cmr_canVSMLatchedStatus_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canVSMPowerDiagnostics_t'), ('\n    uint16_t errorStatus;   /**< @brief Current HVC errors. See cmr_canHVCError_t. */\n    uint8_t hvcMode;        /**< @brief Current HVC operating mode. See cmr_canHVCMode_t. */\n    uint8_t hvcState;       /**< @brief Current internal HVC state. See cmr_canHVCState_t. */\n    uint8_t relayStatus;    /**< @brief Status of AIRs. See cmr_canHVCRelayStatus_t. */\n    uint8_t uptime_s;       /**< @brief HVC uptime in seconds. */\n', 'cmr_canHVCHeartbeat_t'), ('\n    uint8_t modeRequest;    /**< @brief HVC operating mode request. See cmr_canHVCMode_t. */\n', 'cmr_canHVCCommand_t'), ('\n    bool balanceRequest;    /**< @brief HVC balance command. */\n    uint16_t threshold;  /**< @brief Voltage threshold to stop balancing at */\n', 'cmr_canHVCBalanceCommand_t'), ('\n    int32_t battVoltage_mV;    /**< @brief Voltage measured across battery. */\n    int32_t hvVoltage_mV;      /**< @brief Voltage outside accumulator. */\n', 'cmr_canHVCPackVoltage_t'), ('\n    uint16_t minCellTemp_dC;    /**< @brief Pack min cell temp in dC (tenth of degree C). */\n    uint16_t maxCellTemp_dC;    /**< @brief Pack max cell temp in dC (tenth of degree C). */\n    uint8_t minTempBMBIndex;    /**< @brief BMB index of coldest cell. */\n    uint8_t minTempCellIndex;   /**< @brief Index of coldest cell. */\n    uint8_t maxTempBMBIndex;    /**< @brief BMB index of hottest cell. */\n    uint8_t maxTempCellIndex;   /**< @brief Index of hottest cell. */\n', 'cmr_canHVCPackMinMaxCellTemps_t'), ('\n    uint16_t minCellVoltage_mV; /**< @brief Min BMB cell voltage (mV). */\n    uint16_t maxCellVoltage_mV; /**< @brief Max BMB cell voltage (mV). */\n    uint8_t minCellVoltBMB;     /**< @brief */\n    uint8_t minVoltIndex;       /**< @brief Min BMB cell voltage index. */\n    uint8_t maxCellVoltBMB;     /**< @brief */\n    uint8_t maxVoltIndex;       /**< @brief Max BMB cell voltage index. */\n', 'cmr_canHVCPackMinMaxCellVolages_t'), ('\n    int32_t instantCurrent_mA;  /**< @brief Instantaneous current measurement. */\n    int32_t avgCurrent_mA;      /**< @brief (Not working) rolling average of current. */\n', 'cmr_canHVCPackCurrent_t'), ('\n    uint8_t BMB1_2_Errs;  /**< @brief Errors for BMB1&2 (BMB1 = higher 4 bits). */\n    uint8_t BMB3_4_Errs;  /**< @brief Errors for BMB3&4 (BMB3 = higher 4 bits). */\n    uint8_t BMB5_6_Errs;  /**< @brief Errors for BMB5&6 (BMB5 = higher 4 bits). */\n    uint8_t BMB7_8_Errs;  /**< @brief Errors for BMB7&8 (BMB7 = higher 4 bits). */\n    uint8_t BMB9_10_Errs;  /**< @brief Errors for BMB9&10 (BMB9 = higher 4 bits). */\n    uint8_t BMB11_12_Errs;  /**< @brief Errors for BMB11&12 (BMB11 = higher 4 bits). */\n    uint8_t BMB13_14_Errs;  /**< @brief Errors for BMB13&14 (BMB13 = higher 4 bits). */\n    uint8_t BMB15_16_Errs;  /**< @brief Errors for BMB15&16 (BMB15 = higher 4 bits). */\n', 'cmr_canHVCBMBErrors_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canHVIHeartbeat_t'), ('\n    int16_t packCurrent_dA;\n    uint16_t packVoltage_cV;\n    int32_t packPower_W;\n', 'cmr_canPowerSense_t'), ('\n    uint8_t state;          /**< @brief DRS current control state (open or closed position). */\n    uint8_t angle;          /**< @brief DRS setpoint angle for its current state (debug info). */\n    uint8_t pwm_left;       /**< @brief PWM of the left  DRS servo (debug info). */\n    uint8_t pwm_right;      /**< @brief PWM of the right DRS servo (debug info). */\n', 'cmr_canCDCDRSStates_t'), ('\n    float odometer_km;      /**< @brief Odometer in km*/\n', 'cmr_canCDCOdometer_t'), ('\n    uint8_t tcOn;\n    uint8_t yrcOn;\n', 'cmr_canCDCControlsStatus_t'), ('\n    uint8_t powerLimit_kW;\n', 'cmr_canCDCPowerLimit_t'), ('\n    float power_limit_W;\n', 'cmr_canCDCPowerLimitLog_t'), ('\n\tfloat power_limit_max_violation_W;  /**< @brief the maximum amount in W the power hard-limit is violated, expect 0.0 */\n\tuint8_t longest_power_violation_ms; /**< @brief counts the number of clock cycles when power is over the hard limit, expect <2*/\n    uint8_t over_voltage_count;         /**< @brief incremented when pack voltage exceeds 590 */\n    uint8_t under_voltage_count;        /**< @brief incremented when pack voltage under 365 */\n    uint8_t over_temp_count;            /**<@brief incremented when pack temperature exceeds the hard limit, expect 0>*/\n', 'cmr_canCDCSafetyFilterStates_t'), ('\n    uint16_t motor_power_FL;\n    uint16_t motor_power_FR;\n    uint16_t motor_power_RL;\n    uint16_t motor_power_RR;\n', 'cmr_canCDCMotorPower_t'), ('\n\tfloat KCoulombs;\n', 'cmr_canCDCKiloCoulombs_t'), ('\n    int16_t frontLeft_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t frontRight_rpm; /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearLeft_rpm;   /**< @brief Wheel speed on 20e (rpm * 10). */\n    int16_t rearRight_rpm;  /**< @brief Wheel speed on 20e (rpm * 10). */\n} cmr_canCDCWheelVelocity;\n\ntypedef struct {\n    int16_t frontLeft_Nm;   /**< @brief Wheel torque on 20e (Nm * 10). */\n    int16_t frontRight_Nm;  /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearLeft_Nm;    /**< @brief Wheel speed on 20e (Nm * 10). */\n    int16_t rearRight_Nm;   /**< @brief Wheel speed on 20e (Nm * 10). */\n', 'cmr_canCDCWheelTorque_t'), ('\n    float latitude_deg;     /**< @brief Position of car on earth. */\n    float longitude_deg;    /**< @brief Position of car on earth. */\n', 'cmr_canCDCPosePosition_t'), ('\n    int16_t roll_deg;       /**< @brief Roll of the car (deg * 10). */\n    int16_t pitch_deg;      /**< @brief Pitch of the car (deg * 10). */\n    int16_t yaw_deg;        /**< @brief Yaw of the car (deg * 10). */\n    int16_t velocity_deg;   /**< @brief Velocity vector of the car (deg * 10). */\n', 'cmr_canCDCPoseOrientation_t'), ('\n    int16_t longitudinalVel_mps;    /**< @brief Velocity of the car in the forward direction (m/s * 100). */\n    int16_t lateralVel_mps;         /**< @brief Velocity of the car in the right direction (m/s * 100). */\n    int16_t verticalVel_mps;        /**< @brief Velocity of the car in the down direction (m/s * 100). */\n', 'cmr_canCDCPoseVelocity_t'), ('\n    uint8_t requestedState;     /**< @brief Requested state. */\n    uint8_t requestedGear;      /**< @brief Requested gear. */\n    uint8_t requestedDrsMode;   /**< @brief Requested DRS mode. */\n    uint8_t requestedDriver;    /**< @brief Requested Driver for Config Screen. */\n', 'cmr_canDIMRequest_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canDIMPowerDiagnostics_t'), ('\n    uint8_t address;            /**< @brief Buffer index for text. */\n    uint8_t data[4];            /**< @brief Data to write. */\n', 'cmr_canDIMTextWrite_t'), ('\n    uint8_t buttons;                 /**< @brief Button states packed into an uint8_t. {drs,0,1,2,up,down,left,right}*/\n    uint8_t rotaryPos;\n    uint8_t switchValues;\n    uint8_t regenPercent;            /**< @brief Integer percentage for regen. */\n    uint8_t paddle;            /**< @brief Between 0 and 255 for paddle pos*/\n    uint8_t LRUDButtons;     /**< @brief LRUD Button States, packed into an uint8_t*/\n', 'cmr_canDIMActions_t'), ('\n    uint8_t acknowledge;\n', 'cmr_canDIMAck_t'), ('\n    uint8_t config_val_1;\n    uint8_t config_val_2;\n    uint8_t config_val_3;\n    uint8_t config_val_4;\n', 'cmr_canDIMCDCconfig_t'), ('\n    uint8_t torqueRequested;            /**< @brief Torque requested (0-255). */\n    uint8_t throttlePosition;           /**< @brief Throttle position (0-255). */\n    uint16_t brakePressureFront_PSI;     /**< @brief Front brake pressure. */\n    uint8_t brakePedalPosition_percent;         /**< @brief Brake pedal position (0-255). */\n    \n', 'cmr_canFSMData_t'), ('\n    /** @brief Steering wheel angle (-180 to 180 degrees). \n     * Calculated from ADC values using transfer function.\n    */\n    int32_t steeringWheelAngle_millideg_FR;\n    int32_t steeringWheelAngle_millideg_FL;\n\n', 'cmr_canFSMSWAngle_t'), ('\n    uint16_t throttleLeftADC;   /**< @brief Raw left throttle value. */\n    uint16_t throttleRightADC;  /**< @brief Raw right throttle value. */\n    uint16_t brakePedalADC;     /**< @brief Raw brake pedal value. */\n', 'cmr_canFSMPedalsADC_t'), ('\n    uint16_t brakePressureFrontADC;     /**< @brief Raw brake pressure value. */\n    uint16_t steeringWheelAngleADC;     /**< @brief Raw steering wheel value. */\n', 'cmr_canFSMSensorsADC_t'), ('\n    uint16_t busVoltage_mV;     /**< @brief Low-voltage bus voltage (mV). */\n    uint16_t busCurrent_mA;     /**< @brief Low-voltage bus current (mA). */\n', 'cmr_canFSMPowerDiagnostics_t'), ('\n\tuint32_t commitHash;\n\tuint8_t dirtyFlash;\n} cmr_canGitFlashStatus;\n\n// ------------------------------------------------------------------------------------------------\n// AMK Motor controller definitions.\n\n/** @brief AMK motor controller status bits. */\ntypedef enum {\n    CMR_CAN_AMK_STATUS_SYSTEM_READY = (1 << 8),     /**< @brief System ready. */\n    CMR_CAN_AMK_STATUS_ERROR        = (1 << 9),     /**< @brief Error is present. */\n    CMR_CAN_AMK_STATUS_WARNING      = (1 << 10),    /**< @brief Warning is present. */\n    CMR_CAN_AMK_STATUS_HV_EN_ACK    = (1 << 11),    /**< @brief HV enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_HV_EN        = (1 << 12),    /**< @brief HV enabled. */\n    CMR_CAN_AMK_STATUS_INV_EN_ACK   = (1 << 13),    /**< @brief Inverter enabled acknowledgement. */\n    CMR_CAN_AMK_STATUS_INV_EN       = (1 << 14),    /**< @brief Inverter enabled. */\n    CMR_CAN_AMK_STATUS_DERATING_EN  = (1 << 15)     /**< @brief Protective torque derating enabled. */\n', 'cmr_canAMKStatus_t'), ('\n    uint16_t status_bv;         /**< @brief Status bit vector. See cmr_canAMKStatus_t. */\n    int16_t velocity_rpm;       /**< @brief Motor velocity (RPM). */\n    int16_t torqueCurrent_raw;  /**< @brief Raw value for torque producing current. */\n    int16_t magCurrent_raw;     /**< @brief Raw value for magnetizing current. */\n', 'cmr_canAMKActualValues1_t'), ('\n    int16_t motorTemp_dC;       /**< @brief Motor temperature in dC (0.1 C). */\n    int16_t coldPlateTemp_dC;   /**< @brief Cold plate temperature in dC (0.1 C). */\n    uint16_t errorCode;         /**< @brief Inverter error code. */\n    int16_t igbtTemp_dC;        /**< @brief IGBT temperature in dC (0.1 C). */\n', 'cmr_canAMKActualValues2_t'), ('\n    uint16_t control_bv;        /**< @brief Control bit vector. See cmr_canAMKControl_t. */\n    int16_t velocity_rpm;       /**< @brief Velocity setpoint (RPM). */\n    int16_t torqueLimPos_dpcnt; /**< @brief Positive torque limit in 0.1% of 9.8 Nm (nominal torque). */\n    int16_t torqueLimNeg_dpcnt; /**< @brief Negative torque limit in 0.1% of 9.8 Nm (nominal torque). */\n', 'cmr_canAMKSetpoints_t'), ('\n    int32_t instantCurrent_mA; /**< @brief Instant Current (mA). */\n    int32_t averageCurrent_mA; /**< @brief Average Current (mA). */\n', 'cmr_canBMSPackCurrent_t'), ('\n\tuint8_t maxVoltIndex;        /**< @brief Max BMB cell voltage index. */\n    uint8_t minVoltIndex;        /**< @brief Min BMB cell voltage index. */\n    uint16_t maxCellVoltage_mV;  /**< @brief Max BMB cell voltage (mV). */\n    uint16_t minCellVoltage_mV;  /**< @brief Min BMB cell voltage (mV). */\n', 'cmr_canBMSBMBStatusVoltage_t'), ('\n\tuint8_t maxTempIndex;        /**< @brief Max BMB cell temp index. */\n\tuint8_t minTempIndex;        /**< @brief Min BMB cell temp index. */\n    int16_t maxCellTemp_C;       /**< @brief Max BMB cell temp (C). */\n    int16_t minCellTemp_C;       /**< @brief Min BMB cell temp (C). */\n', 'cmr_canBMSBMBStatusTemp_t'), ('\n\tuint16_t minCellVoltage_mV;  /**< @brief Min pack cell voltage (mV). */\n\tuint16_t maxCellVoltage_mV;  /**< @brief Max pack cell voltage (mV). */\n\tuint8_t minVoltageBMBNum;    /**< @brief Min pack cell voltage BMB number. */\n\tuint8_t minVoltageCellNum;   /**< @brief Min pack cell voltage cell number. */\n\tuint8_t maxVoltageBMBNum;    /**< @brief Max pack cell voltage BMB number. */\n\tuint8_t maxVoltageCellNum;   /**< @brief Max pack cell voltage cell number. */\n', 'cmr_canBMSMinMaxCellVoltage_t'), ('\n    uint16_t minCellTemp_C;      /**< @brief Min pack cell temp (C). */\n    uint16_t maxCellTemp_C;      /**< @brief Max pack cell temp (C). */\n    uint8_t minTempBMBNum;       /**< @brief Min pack cell temp BMB number. */\n    uint8_t minTempCellNum;      /**< @brief Min pack cell temp cell number. */\n    uint8_t maxTempBMBNum;       /**< @brief Max pack cell temp BMB number. */\n    uint8_t maxTempCellNum;      /**< @brief Max pack cell temp cell number. */\n', 'cmr_canBMSMinMaxCellTemperature_t'), ('\n    uint8_t vbatt_mV;       /**< @brief LV battery voltage (mV). */\n    uint8_t vAIR_mV;        /**< @brief AIR voltage (mV). */\n    uint8_t safety_mV;       /**< @brief Safety circuit voltage (mA). */\n\tuint8_t iDCDC_mA;       /**< @brief DCDC current (mA). */\n', 'cmr_canBMSLowVoltage_t'), ('\n    uint32_t timestamp;         /**< @brief Timestamp in microseconds. */\n    uint16_t general_status;    /**< @brief General status bit vector. */\n    uint16_t clock_status;      /**< @brief Clock status bit vector. */\n', 'cmr_canSBGStatus1_t'), ('\n    uint32_t com_status;        /**< @brief Com status bit vector. */\n    uint32_t aiding_status;     /**< @brief Aiding status bit vector. */\n', 'cmr_canSBGStatus2_t'), ('\n    uint32_t solution_status;   /**< @brief Solution status bit vector. */\n    uint16_t heave_status;      /**< @brief Heave status bit vector. */\n', 'cmr_canSBGStatus3_t'), ('\n    int32_t latitude;           /**< @brief Latitude (Degrees times 10^7). */\n    int32_t longitude;          /**< @brief Longitude (Degrees times 10^7). */\n', 'cmr_canSBGEKFPosition_t'), ('\n    int16_t roll;               /**< @brief Car Roll (radians times 10^4). */\n    int16_t pitch;              /**< @brief Car Pitch (radians times 10^4). */\n    int16_t yaw;                /**< @brief Car Yaw (radians times 10^4). */\n', 'cmr_canSBGEKFOrient_t'), ('\n    int16_t velocity_n;         /**< @brief Velocity in North Direction (m/s times 100). */\n    int16_t velocity_e;         /**< @brief Velocity in East Direction (m/s times 100). */\n    int16_t velocity_d;         /**< @brief Velocity in Down Direction (m/s times 100). */\n', 'cmr_canSBGEKFVelocity_t'), ('\n    int16_t velocity_forward;     /**< @brief Velocity in Car Forward Direction (m/s times 100). */\n    int16_t velocity_right;       /**< @brief Velocity in Car Right Direction (m/s times 100). */\n    int16_t velocity_down;        /**< @brief Velocity in Car Down Direction (m/s times 100). */\n', 'cmr_canSBGBodyVelocity_t'), ('\n    int16_t accel_x_mps2;         /**< @brief Acceleration in Car Forward Direction (m/s^2 times 100). */\n    int16_t accel_y_mps2;         /**< @brief Acceleration in Car Right Direction (m/s^2 times 100). */\n    int16_t accel_z_mps2;         /**< @brief Acceleration in Car Down Direction (m/s^2 times 100). */\n', 'cmr_canSBGIMUAcceleration_t'), ('\n    int16_t gyro_x_rads;        /**< @brief Roll rate around the Car Forward Direction (rad/s times 1000). */\n    int16_t gyro_y_rads;        /**< @brief Roll rate around the Car Right Direction (rad/s times 1000). */\n    int16_t gyro_z_rads;        /**< @brief Roll rate around the Car Down Direction (rad/s times 1000). */\n', 'cmr_canSBGIMUGyro_t'), ('\n    int16_t angle_track_rad;        /**< @brief Track course angle/direction of travel (rad times 10^4). */\n    int16_t angle_slip_rad;         /**< @brief Vehicle slip angle (rad times 10^4). */\n    uint16_t curvature_radius_m;    /**< @brief Curvature radius based on down rotation rate (meters times 10^2). */\n    uint8_t status;                 /**< @brief Status bitmasks as AUTO_STATUS definition. */\n', 'cmr_canSBGAutomotive_t'), ('\n    uint8_t msb;\n    uint8_t lsb;\n} big_endian_16_t;\n\n\ntypedef union {\n    struct {\n        uint8_t lsb;\n        uint8_t msb;\n    } data;\n    int16_t parsed;\n} int16_parser;\n\nstatic int16_t parse_int16(volatile big_endian_16_t *big) {\n    static int16_parser parser;\n    parser.data.msb = big->msb;\n    parser.data.lsb = big->lsb;\n    return parser.parsed;\n} \n\ntypedef struct {\n    big_endian_16_t q0;\n    big_endian_16_t q1;\n    big_endian_16_t q2;\n    big_endian_16_t q3;\n', 'cmr_canMovellaQuaternion_t'), ('\n    big_endian_16_t yaw;\n    big_endian_16_t pitch;\n    big_endian_16_t roll;\n', 'cmr_canMovellaEulerAngles_t'), ('\n    big_endian_16_t gyro_x;\n    big_endian_16_t gyro_y;\n    big_endian_16_t gyro_z;\n', 'cmr_canMovellaIMUGyro_t'), ('\n    big_endian_16_t accel_x;\n    big_endian_16_t accel_y;\n    big_endian_16_t accel_z;\n', 'cmr_canMovellaIMUAccel_t'), ('\n    big_endian_16_t vel_x;\n    big_endian_16_t vel_y;\n    big_endian_16_t vel_z;\n', 'cmr_canMovellaVelocity_t'), ('\n    \n    // https://mtidocs.movella.com/messages$XDI_StatusWord\n    \n    // Bits 24-31.\n    // LSBit first.\n    uint8_t filter_mode_1:2;\n    uint8_t have_gnss_time_pulse:1;\n    uint8_t rtk_status:2;\n    uint8_t reserved_4:3;\n    \n    // Bits 16-23.\n    // LSBit first.\n    uint8_t clipflag_mag_z:1;\n    uint8_t reserved_2:2;\n    uint8_t clipping_indication:1;\n    uint8_t reserved_3:1;\n    uint8_t sync_in_marker:1;\n    uint8_t sync_out_marker:1;\n    uint8_t filter_mode_2:1;\n\n    // Bits 8-15.\n    // LSBit first.\n    uint8_t clipflag_acc_x:1;\n    uint8_t clipflag_acc_y:1;\n    uint8_t clipflag_acc_z:1;\n    uint8_t clipflag_gyr_x:1;\n    uint8_t clipflag_gyr_y:1;\n    uint8_t clipflag_gyr_z:1;\n    uint8_t clipflag_mag_x:1;\n    uint8_t clipflag_mag_y:1;\n    \n    // Bits 0-7.\n    // LSBit first.\n    uint8_t self_test:1;\n    uint8_t filter_valid:1;\n    uint8_t gnss_fix:1;\n    uint8_t no_rotation_update:2;\n    uint8_t representative_motion:1;\n    uint8_t clock_bias_estimation:1;\n    uint8_t reserved_1:1;\n\n', 'cmr_canMovellaStatus_t'), ('\n    int16_t cog_x;\n    int16_t cog_y;\n    float slip_angle;\n', 'cmr_canCOGVelocity_t'), ('\n    int16_t fl_x;\n    int16_t fl_y;\n    int16_t fr_x;\n    int16_t fr_y;\n', 'cmr_canFrontWheelVelocity_t'), ('\n    int16_t rl_x;\n    int16_t rl_y;\n    int16_t rr_x;\n    int16_t rr_y;\n', 'cmr_canRearWheelVelocity_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_raw_t'), ("\n    int16_t delta_voltage;        /**< @brief differential voltage in the wheatstone bridge */\n    int16_t calibrated_output_f;  /**< @brief force output from the loadcell. */\n    int16_t internal_temp;        /**< @brief amp's internal temp */\n    int16_t external_temp;        /**< @brief amp's external temp */\n", 'cmr_canIzzie_loadcell_calibrated_t'), ('\n    int16_t controls_elapsed_time;\n    int16_t controls_sbg_speed_mps;\n    int16_t controls_target_velocity;\n    int16_t controls_target_accel;\n', 'cmr_can_controls_debug_global_t'), ('\n    int16_t controls_current_slip_FR;\n    int16_t controls_slip_correction_active_FR;\n    int16_t controls_wheel_speed_mps_actual_FR;\n    int16_t controls_wheel_speed_mps_target_FR;\n', 'cmr_can_controls_debug_FR_t'), ('\n    int16_t controls_current_slip_FL;\n    int16_t controls_slip_correction_active_FL;\n    int16_t controls_wheel_speed_mps_actual_FL;\n    int16_t controls_wheel_speed_mps_target_FL;\n', 'cmr_can_controls_debug_FL_t'), ('\n    int16_t controls_current_slip_RR;\n    int16_t controls_slip_correction_active_RR;\n    int16_t controls_wheel_speed_mps_actual_RR;\n    int16_t controls_wheel_speed_mps_target_RR;\n', 'cmr_can_controls_debug_RR_t'), ('\n    int16_t controls_current_slip_RL;\n    int16_t controls_slip_correction_active_RL;\n    int16_t controls_wheel_speed_mps_actual_RL;\n    int16_t controls_wheel_speed_mps_target_RL;\n', 'cmr_can_controls_debug_RL_t'), ('\n    int16_t controls_current_yaw_rate;\n    int16_t controls_target_yaw_rate;\n    int16_t controls_bias;\n    int16_t controls_pid;\n', 'cmr_can_controls_pid_debug_t'), ('\n    uint8_t seconds;\n    uint8_t minutes;\n    uint8_t hours;\n    uint8_t date;\n    uint8_t month;\n    uint8_t year;\n    uint8_t err; /* 1 in error state and 0 otherwise */\n', 'cmr_can_rtc_data_t'), ('\n    float slipRatio_FL;\n    float slipRatio_FR;\n', 'cmr_can_front_slip_ratio_data_t'), ('\n    float slipRatio_RL;\n    float slipRatio_RR;\n', 'cmr_can_rear_slip_ratio_data_t'), ('\n    float omega_FL;\n    float omega_FR;\n', 'cmr_can_front_whl_speed_setpoint_t'), ('\n    float omega_RL;\n    float omega_RR;\n', 'cmr_can_rear_whl_speed_setpoint_t'), ('\n    float v_whl_fl;\n    float v_whl_fr;\n', 'cmr_can_front_whl_velocity_t'), ('\n    float v_whl_rl;\n    float v_whl_rr;\n', 'cmr_can_rear_whl_velocity_t'), ('\n    float moment_req_Nm;\n    float lin_accel_Nm;\n', 'cmr_can_solver_inputs_t'), ('\n    int16_t combined_normalized_throttle;\n    bool allow_regen;\n    uint8_t placeholder[5];\n', 'cmr_can_solver_aux_t'), ('\n    uint16_t k_lin;\n    uint16_t k_yaw;\n    uint16_t k_tie;\n', 'cmr_can_solver_settings_t'), ('\n    int32_t current;    /**< @brief Current (amps * 2^16). */\n    int32_t voltage;    /**< @brief Voltage (volts * 2^16). */\n', 'cmr_canEMDMeasurements_t'), ('\n    uint32_t therm_1;       /**< @brief Front damper length in mm */\n    uint32_t therm_2;        /**< @brief Rear damper length in mm */\n', 'cmr_canDAQTherm_t'), ('\n    big_endian_16_t differential_voltage_uv;\n    big_endian_16_t force_output_N;\n    big_endian_16_t internal_temp;\n    big_endian_16_t external_temp;\n', 'cmr_canIZZELoadCell_t'), ('\n    uint8_t state;\n', 'cmr_canMemoratorHeartbeat_t'), ('\n\tuint32_t test_id;\n', 'cmr_canTestID_t')]
finished parsing fields in can_types.h

formatted fields

done
