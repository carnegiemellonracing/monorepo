/*
 * uart.c
 *
 *  Created on: Jul 26, 2020
 *      Author: vamsi
 */

#include <CMR/tasks.h>      // CMR task interface
#include <CMR/config.h>     // CMR configuration interface
#include <CMR/panic.h>      // bad things
#include <CMR/uart.h>

#include "uart.h"       // Interface to implement
#include "crc.h"

//-----------------------------------------------------------------------------
// GLOBAL VARIABLE DEFINITIONS                                                |
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// STATIC VARIABLE DEFINITIONS                                                |
//-----------------------------------------------------------------------------

static cmr_uart_t uart;

//-----------------------------------------------------------------------------
// STATIC HELPER FUNCTION PROTOTYPES                                          |
//-----------------------------------------------------------------------------
static cmr_uart_result_t uart_getChar(cmr_uart_t *uart, uint8_t *c);
static cmr_uart_result_t uart_sendMessage(cmr_uart_t *uart, uint8_t message[], uint16_t messageLength);
//-----------------------------------------------------------------------------
// GLOBAL INTERFACE FUNCTIONS                                                 |
//-----------------------------------------------------------------------------
/** UART Init
 * This function will initialize the uart.
 */
void uartInit(void) {
	const UART_InitTypeDef uartInit = {
			.BaudRate = BQ_BAUD_RATE,
			.WordLength = UART_WORDLENGTH_8B,
			.StopBits = UART_STOPBITS_1,
			.Parity = UART_PARITY_NONE,
			.HwFlowCtl = UART_HWCONTROL_NONE,
			.Mode = UART_MODE_TX_RX,
			.OverSampling = UART_OVERSAMPLING_16
	};

	cmr_uart_polling_init(
			&uart, UART5, &uartInit,
			GPIOB, GPIO_PIN_12,     /* rx */
			GPIOB, GPIO_PIN_13      /* tx */
	);

	return;
}



/** UART Receive Response
 * This helper function will receive a response and store the result
 * in the input uart_response_t object using the given USART
 * @param response A pointer to the USART object we are receiving from
 * @param deviceResponse Boolean indicating whether this is a single device read or not
 * @return The status of the UART result (success or failure)
 */
cmr_uart_result_t uart_receiveResponse(uart_response_t *response, bool deviceResponse) {

	cmr_uart_result_t retvTotal = UART_SUCCESS;
	cmr_uart_result_t retv = UART_SUCCESS;

	uint8_t responseLen;
	retv = uart_getChar(&uart, &responseLen);
	if(retv != UART_SUCCESS) {
		retvTotal = UART_FAILURE;
	}
	if (responseLen == 0) {
		retvTotal = UART_FAILURE;
	}

	response->len_bytes = responseLen;

	uint8_t deviceAddr;
	if(deviceResponse) {
		retv = uart_getChar(&uart, &deviceAddr);
		if(retv != UART_SUCCESS) {
			retvTotal = UART_FAILURE;
		}
		response->deviceAddress = deviceAddr;
	}
	else {
		response->deviceAddress = 0;
	}

	uint8_t registerValues[2] = {0};
	retv = uart_getChar(&uart, &registerValues[0]);
	if(retv != UART_SUCCESS) {
		retvTotal = UART_FAILURE;
	}
	retv = uart_getChar(&uart, &registerValues[1]);
	if(retv != UART_SUCCESS) {
		retvTotal = UART_FAILURE;
	}
	response->registerAddress = (((uint16_t)registerValues[1])<<8) | ((uint16_t)registerValues[0]);

	uint8_t c = 0;
	uint16_t receivedIndex = 0;
	while((receivedIndex < responseLen) && (retvTotal == UART_SUCCESS)) {

		retv = uart_getChar(&uart, &c);
		if(retv != UART_SUCCESS) {
			retvTotal = UART_FAILURE;
		}
		response->data[receivedIndex] = c;
		receivedIndex++;
	}

	retv = uart_getChar(&uart, &response->crc[0]);
	if(retv != UART_SUCCESS) {
		retvTotal = UART_FAILURE;
	}
	retv = uart_getChar(&uart, &response->crc[1]);
	if(retv != UART_SUCCESS) {
		retvTotal = UART_FAILURE;
	}



	return retvTotal;
}

/** UART Send Command
 * This helper function will take an input command and pack it into a Byte
 * array that can be sent over UART. Additionally, it returns via reference
 * whether or not this input command expects a response based on the message.
 * @param command A reference to the desired command
 * @param message A buffer to hold the message generated by the given command
 * @return The result of the command send
 */
cmr_uart_result_t uart_sendCommand(const uart_command_t *command) {

	uint8_t message[128] = {0};
	uint8_t currByte = 0;

	uint8_t initByte = ((command->readWrite) << 4) | ((0x07 & (command->dataLen)-1));
	message[currByte] = initByte;
	currByte++;

	//append device address
	if(command->deviceAddress != 0xFF) {
		message[currByte] = command->deviceAddress;
		currByte++;
	}


	//append register addresses
	message[currByte] = (uint8_t)(command->registerAddress >> 8);
	currByte++;
	message[currByte] = (uint8_t)(command->registerAddress & 0xFF);
	currByte++;

	// Put the individual bytes into the message
	for(int i = 0; i < command->dataLen; i++) {
		message[currByte] = command->data[i];
		currByte++;
	}

	// Calculate the CRC and put at the end of the message
	uint16_t crc = calculateCRC(message, currByte);
	message[currByte] = (crc) & 0x00FF;
	currByte++;
	message[currByte] = (crc >> 8) & 0x00FF;
	currByte++;

	cmr_uart_result_t res;
	res = uart_sendMessage(&uart, message, currByte);
	return res;
}


/** UART Get Char
 * This helper function will attempt to read one byte from the RX line and
 * store the value of the read character c into the passed reference
 * @param uart A pointer to the UART object we are reading from
 * @param c A reference to the location we want to store the read character
 * @return The status of the UART result (success or failure)
 */
static cmr_uart_result_t uart_getChar(cmr_uart_t *uart, uint8_t *c) {
	return cmr_uart_pollingRX(uart, c, UART_TIMEOUT);
}

/** UART Send Message
 * This helper function will send the message stored in the input message array
 * up to the number of bytes specified by the input messageLength using the
 * given USART
 * @param uart A pointer to the USART object we are sending from
 * @param message The array containing the bytes we want to send
 * @param messageLength The number of bytes from message to send
 * @return The status of the UART result (success or failure)
 */
static cmr_uart_result_t uart_sendMessage(cmr_uart_t *uart, uint8_t message[], uint16_t messageLength) {
	return cmr_uart_pollingTX(uart, message, messageLength);
}
